import java.util.Arrays;

//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {
    
	private Record[] table;		// Included a global variable or our table
	private double loadFactor; 	// Included a load factor for our table
	
	// Left over function used for original hashing
	// that would return the next prime if 
	// x was not prime
	int nextPrime(int x)
	{
		int i = 3; 
		if (x%2 == 0) x++;
		while (i < Math.sqrt(x))
			{
				if (x % i == 0)
				{
					i = 3;
					x += 2;
				}
				else i += 2;
			}
		return x;
	}
    //
    // Create an empty table big enough to hold maxSize records.
    //
    public StringTable(int maxSize) 
    {
    	int size = 2;	//Ignored max size due to Part II
    	
    	this.table = new Record[size]; 
    	for (int i = 0; i < size; i++)
    			this.table[i] = null;
    	this.loadFactor = 0;
    }
    
    
    // This method will take our original table and passes it  
    // around to create a new table with a doubled size and 
    // and then re-insert the old values.
    public void DoubleTable()
    {
    	 int newSize = 2*this.table.length;
    	 Record[] tempTable = this.table;
    	 this.loadFactor = 0;
    	 Record[] newTable = new Record[newSize];
    	 for (int i = 0; i< newSize; i++)
    		 newTable[i] = null;
    	 this.table = newTable;
    	 for (int j = 0; j < newSize/2; j++)
    		 if (tempTable[j] != null)	// avoid re-inserting null values!!
    		 {
    		 this.insert(tempTable[j]); 
    		 } 
    }
    
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
    public boolean insert(Record r) 
    { 
    	int k = toHashKey(r.key);
    	int s0 = baseHash(k)%this.table.length;
    	int s = baseHash(k)%this.table.length;
    	int i = 0;
    	if (this.loadFactor > 1/4)
    		{							// Check the load factor, 
    		this.DoubleTable();			// create a larger table if 
    		this.insert(r);				// necessary
    		}
 
    	while (this.table[s] != null && this.table[s].key != ("DELETED") 
    			&& this.table[s] != r) // finding an empty slot to put in  
    		{								// new record
    		s = s(s,k);
    		if (i!=0 && s(s,k) == s0)
    			{
    			this.DoubleTable();			// fail check to avoid collisions 
    			this.insert(r);				
    			}
    		i+=1;
    		}
    	
    /*	if (this.table[s(i,k)] == r)
    		{								
    		this.DoubleTable();				// fail check to avoid collisions 
    		this.insert(r);					// (not necessary?)
    		} */
    	this.table[s] = r;						// finally insert r
    	this.loadFactor += 1/this.table.length; // increase load factor from insert
    	return true; 
    }
    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	int i = 0;
    	int k = toHashKey(r.key);
    	int s0 = baseHash(k)%this.table.length;
    	int s = baseHash(k)%this.table.length;
    	
    	while (this.table[s].key != r.key) 
    		{
    		if (i!=0 && s == s0) return;	// r was not found!
    		s = s(s,k);
    		i+=1;
    		}
    	
    	this.table[s] = new Record("DELETED");	
    	this.loadFactor -= 1/this.table.length;
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int i = 0;
    	int k = toHashKey(key);
    	int s0 = baseHash(k)%this.table.length;
    	int s = baseHash(k)%this.table.length;
    	
    	while (true)
    	{
    		if (this.table[s] == null) return null;
    		if (i!=0 && s == s0) return null;
    // Check to see if hash values aren't the same
    // if not, we can pass by them to the next term.
    		if (k != this.table[s].hashedKey); // Part II speed up searches!
    		else if (this.table[s].key.equals(key)) return this.table[s];
    		s = s(s,k);
    		i+=1;
    	}
	
    }
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    public static int toHashKey(String s) 	// changed method to public static
    {										// to be able to access in Record.java
	int A = 1952786893;	
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
	// Fill in your own hash function here	
    	double phi = 0.61803398874989484820458683436564; // golden ratio
    	return (int)(this.table.length*(phi*hashKey-(int)(phi*hashKey)));
    }
    
    int stepHash(int hashKey)
    {
	// Fill in your own hash function here
    	double phi = 0.73205080756887729352744634150587; // root(3) - 1
    	int h2 = (int)(this.table.length*(phi*hashKey-(int)(phi*hashKey)));
    	if (h2%2==0) return h2+1; // return an odd value per Part II and non-0
    	else
    	 return h2;
    }
    
    int s(int s, int k) // made a method to include both hash functions.
    {
    	return (s+stepHash(k))%this.table.length;
    }
}
